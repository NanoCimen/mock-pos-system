import { Router, Request, Response } from 'express';
import pool from '../../db/connection';
import { TicketItem, AddItemsRequest } from '../../types/index';
import { shouldSimulateFailure, simulateDelay } from '../../utils/helpers';

const router = Router();

// GET /api/v1/tickets/:ticketId/items - Get all items for a ticket
router.get('/:ticketId/items', async (req: Request, res: Response) => {
  try {
    await simulateDelay();
    
    if (shouldSimulateFailure()) {
      return res.status(500).json({
        success: false,
        error: 'Simulated server error',
      });
    }

    const { ticketId } = req.params;

    // Verify ticket exists
    const ticketResult = await pool.query(
      'SELECT * FROM tickets WHERE tickets.id = $1',
      [ticketId]
    );

    if (ticketResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Ticket not found',
      });
    }

    const itemsResult = await pool.query(
      `SELECT
        ticket_items.id,
        ticket_items.ticket_id,
        ticket_items.name,
        ticket_items.price,
        ticket_items.quantity,
        ticket_items.paid_amount,
        ticket_items.created_at
      FROM ticket_items
      WHERE ticket_items.ticket_id = $1
      ORDER BY ticket_items.created_at`,
      [ticketId]
    );

    const items: TicketItem[] = itemsResult.rows.map((itemRow: any) => {
      const paidAmount = itemRow.paid_amount || 0;
      const itemTotalPrice = itemRow.price * itemRow.quantity;
      return {
        id: itemRow.id,
        ticket_id: itemRow.ticket_id,
        name: itemRow.name,
        price: itemRow.price,
        quantity: itemRow.quantity,
        paid_amount: paidAmount,
        is_paid: paidAmount >= itemTotalPrice,
        created_at: itemRow.created_at,
      };
    });

    return res.json({
      success: true,
      data: items,
    });
  } catch (error: any) {
    console.error('Error fetching items:', error);
    return res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

// POST /api/v1/tickets/:ticketId/items - Add items to a ticket
router.post('/:ticketId/items', async (req: Request, res: Response) => {
  try {
    await simulateDelay();
    
    if (shouldSimulateFailure()) {
      return res.status(500).json({
        success: false,
        error: 'Simulated server error',
      });
    }

    const { ticketId } = req.params;
    const { items } = req.body as AddItemsRequest;

    if (!items || !Array.isArray(items) || items.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'items array is required',
      });
    }

    // Verify ticket exists and is open
    const ticketResult = await pool.query(
      'SELECT * FROM tickets WHERE tickets.id = $1',
      [ticketId]
    );

    if (ticketResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Ticket not found',
      });
    }

    const ticket = ticketResult.rows[0];
    if (ticket.status === 'CANCELLED') {
      return res.status(400).json({
        success: false,
        error: 'Cannot add items to a cancelled ticket',
      });
    }

    if (ticket.status === 'PAID') {
      return res.status(400).json({
        success: false,
        error: 'Cannot add items to a fully paid ticket',
      });
    }

    const addedItems: TicketItem[] = [];

    // Insert items (UUID auto-generated by database)
    for (const item of items) {
      if (!item.name || item.price === undefined || !item.quantity) {
        return res.status(400).json({
          success: false,
          error: 'Each item must have name, price, and quantity',
        });
      }

      if (item.quantity <= 0) {
        return res.status(400).json({
          success: false,
          error: 'Quantity must be greater than 0',
        });
      }

      if (item.price < 0) {
        return res.status(400).json({
          success: false,
          error: 'Price must be non-negative',
        });
      }

      const result = await pool.query(
        `INSERT INTO ticket_items (ticket_id, name, price, quantity, paid_amount, created_at)
         VALUES ($1, $2, $3, $4, 0, NOW())
         RETURNING 
           ticket_items.id,
           ticket_items.ticket_id,
           ticket_items.name,
           ticket_items.price,
           ticket_items.quantity,
           ticket_items.paid_amount,
           ticket_items.created_at`,
        [ticketId, item.name, item.price, item.quantity]
      );

      const row = result.rows[0];
      const paidAmount = row.paid_amount || 0;
      const itemTotalPrice = row.price * row.quantity;
      
      addedItems.push({
        id: row.id,
        ticket_id: row.ticket_id,
        name: row.name,
        price: row.price,
        quantity: row.quantity,
        paid_amount: paidAmount,
        is_paid: paidAmount >= itemTotalPrice,
        created_at: row.created_at,
      });
    }

    // Recalculate ticket total_amount
    const allItemsResult = await pool.query(
      `SELECT 
        ticket_items.price,
        ticket_items.quantity
      FROM ticket_items 
      WHERE ticket_items.ticket_id = $1`,
      [ticketId]
    );

    const totalAmount = allItemsResult.rows.reduce(
      (sum, row) => sum + row.price * row.quantity,
      0
    );

    // Update ticket total_amount
    await pool.query(
      `UPDATE tickets 
       SET total_amount = $1, 
           updated_at = NOW() 
       WHERE tickets.id = $2`,
      [totalAmount, ticketId]
    );

    return res.status(201).json({
      success: true,
      data: addedItems,
    });
  } catch (error: any) {
    console.error('Error adding items:', error);
    return res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

// PATCH /api/v1/items/:itemId - Update an item (notes only - paid_amount managed via payments)
router.patch('/:itemId', async (req: Request, res: Response) => {
  try {
    await simulateDelay();
    
    if (shouldSimulateFailure()) {
      return res.status(500).json({
        success: false,
        error: 'Simulated server error',
      });
    }

    const { itemId } = req.params;
    const { notes } = req.body as { notes?: string };

    // Get item
    const itemResult = await pool.query(
      `SELECT 
        ticket_items.id,
        ticket_items.ticket_id,
        ticket_items.name,
        ticket_items.price,
        ticket_items.quantity,
        ticket_items.paid_amount,
        ticket_items.created_at
      FROM ticket_items 
      WHERE ticket_items.id = $1`,
      [itemId]
    );

    if (itemResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Item not found',
      });
    }

    const item = itemResult.rows[0];

    // Verify ticket is not cancelled
    const ticketResult = await pool.query(
      'SELECT * FROM tickets WHERE tickets.id = $1',
      [item.ticket_id]
    );

    if (ticketResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Ticket not found',
      });
    }

    const ticket = ticketResult.rows[0];
    if (ticket.status === 'CANCELLED') {
      return res.status(400).json({
        success: false,
        error: 'Cannot update items on a cancelled ticket',
      });
    }

    // Only allow updating notes (paid_amount is managed via payments endpoint)
    if (notes === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Only notes field can be updated',
      });
    }

    // Note: In the new schema, ticket_items doesn't have a notes column
    // If you need notes, you'd need to add it to the schema
    // For now, just return the item as-is
    
    const paidAmount = item.paid_amount || 0;
    const itemTotalPrice = item.price * item.quantity;
    
    const updatedItem: TicketItem = {
      id: item.id,
      ticket_id: item.ticket_id,
      name: item.name,
      price: item.price,
      quantity: item.quantity,
      paid_amount: paidAmount,
      is_paid: paidAmount >= itemTotalPrice,
      created_at: item.created_at,
    };

    return res.json({
      success: true,
      data: updatedItem,
    });
  } catch (error: any) {
    console.error('Error updating item:', error);
    return res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

export default router;
